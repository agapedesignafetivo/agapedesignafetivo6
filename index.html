<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <title>Câmera com LUT e Moldura</title>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
      height: 100%;
      width: 100%;
    }

    #camera-wrap {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background: black;
    }

    canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    #frame {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    #buttons {
      position: fixed;
      bottom: 25px;
      width: 100%;
      display: flex;
      justify-content: center;
      gap: 20px;
      z-index: 20;
    }

    .icon-btn {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      cursor: pointer;
      object-fit: cover;
      border: none;
      background: none;
      padding: 0;
      transition: transform 0.2s;
    }

    .icon-btn:hover { transform: scale(1.1); }

    #download { display: none; }
  </style>
</head>
<body>

<div id="camera-wrap">
  <video id="video" autoplay playsinline muted style="display:none;"></video>
  <canvas id="canvas"></canvas>
  <img id="frame" src="moldura.png">
</div>

<div id="buttons">
  <img id="switchBtn" class="icon-btn" src="trocarcamera.png" title="Trocar câmera">
  <img id="snapBtn" class="icon-btn" src="tirarfoto.png" title="Tirar Foto">
</div>

<a id="download" download="fotomoldurapersonalizada.png"></a>

<script type="module">
  import * as twgl from 'https://cdn.jsdelivr.net/npm/twgl.js@4.21.3/dist/4.x/twgl-full.module.js';

  const video = document.getElementById('video');
  const canvas = document.getElementById('canvas');
  const ctx2d = canvas.getContext('2d');
  const frame = document.getElementById('frame');
  const snapBtn = document.getElementById('snapBtn');
  const switchBtn = document.getElementById('switchBtn');
  const download = document.getElementById('download');

  let usingFront = true;
  let stream = null;

  // Carregar LUT primeiro
  const lutImg = new Image();
  lutImg.src = "lut.png"; // <- seu LUT
  let lutLoaded = false;
  lutImg.onload = () => {
    lutLoaded = true;
    console.log("LUT carregado!");
    startCamera(); // só inicia a câmera depois que o LUT carregar
  }

  async function startCamera() {
    if (stream) stream.getTracks().forEach(t => t.stop());
    const constraints = { video: { facingMode: usingFront ? "user" : "environment" } };
    try {
      stream = await navigator.mediaDevices.getUserMedia(constraints);
      video.srcObject = stream;
    } catch(e) {
      alert("Não foi possível acessar a câmera: " + e.message);
      return;
    }

    video.style.transform = usingFront ? "scaleX(-1)" : "scaleX(1)";

    await new Promise(r => video.onloadedmetadata = r);
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;

    drawLoop();
  }

  switchBtn.addEventListener('click', () => {
    usingFront = !usingFront;
    startCamera();
  });

  // --- WebGL LUT setup ---
  const gl = canvas.getContext('webgl');
  if(!gl){ alert("WebGL não disponível"); }

  let programInfo, bufferInfo, textureVideo, textureLUT;

  const vertexShaderSrc = `
    attribute vec4 position;
    attribute vec2 texcoord;
    varying vec2 v_texcoord;
    void main() {
      gl_Position = position;
      v_texcoord = texcoord;
    }
  `;

  const fragmentShaderSrc = `
    precision mediump float;
    varying vec2 v_texcoord;
    uniform sampler2D u_video;
    uniform sampler2D u_lut;
    void main() {
      vec4 color = texture2D(u_video, v_texcoord);
      float blueColor = color.b * 63.0;

      vec2 quad1;
      quad1.y = floor(floor(blueColor) / 8.0);
      quad1.x = floor(blueColor) - (quad1.y * 8.0);

      vec2 quad2;
      quad2.y = floor(ceil(blueColor) / 8.0);
      quad2.x = ceil(blueColor) - (quad2.y * 8.0);

      vec2 texPos1;
      texPos1.x = (quad1.x * 0.125) + 0.5/512.0 + ((color.r) * 0.125);
      texPos1.y = (quad1.y * 0.125) + 0.5/512.0 + ((color.g) * 0.125);

      vec2 texPos2;
      texPos2.x = (quad2.x * 0.125) + 0.5/512.0 + ((color.r) * 0.125);
      texPos2.y = (quad2.y * 0.125) + 0.5/512.0 + ((color.g) * 0.125);

      vec4 newColor1 = texture2D(u_lut, texPos1);
      vec4 newColor2 = texture2D(u_lut, texPos2);

      float mixBlue = fract(blueColor);
      gl_FragColor = mix(newColor1, newColor2, mixBlue);
      gl_FragColor.a = 1.0;
    }
  `;

  function setupGL() {
    programInfo = twgl.createProgramInfo(gl, [vertexShaderSrc, fragmentShaderSrc]);
    bufferInfo = twgl.createBufferInfoFromArrays(gl, {
      position: [-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1],
      texcoord: [0,0, 1,0, 0,1, 0,1, 1,0, 1,1]
    });

    textureVideo = twgl.createTexture(gl, { width: 1, height:1, min: gl.LINEAR });
    textureLUT = twgl.createTexture(gl, { src: lutImg, min: gl.LINEAR });
  }

  function drawLoop() {
    if (!lutLoaded) {
      requestAnimationFrame(drawLoop);
      return;
    }

    twgl.resizeCanvasToDisplaySize(gl.canvas);
    gl.viewport(0,0,gl.canvas.width, gl.canvas.height);

    gl.bindTexture(gl.TEXTURE_2D, textureVideo);
    gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,video);

    gl.useProgram(programInfo.program);
    twgl.setBuffersAndAttributes(gl, programInfo, bufferInfo);
    twgl.setUniforms(programInfo, { u_video: textureVideo, u_lut: textureLUT });
    twgl.drawBufferInfo(gl, bufferInfo);

    // Desenhar moldura no topo
    ctx2d.clearRect(0,0,canvas.width,canvas.height);
    ctx2d.drawImage(canvas,0,0);
    ctx2d.drawImage(frame,0,0,canvas.width,canvas.height);

    requestAnimationFrame(drawLoop);
  }

  snapBtn.addEventListener('click', () => {
    const img = canvas.toDataURL('image/png');
    download.href = img;
    download.click();
  });

  setupGL();
</script>

</body>
</html>
